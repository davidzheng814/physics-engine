var Matter = require('matter-js');
var MatterAttractors = require('matter-attractors');
var fs = require('fs');
var path = require('path');
var readline = require('readline');
var child_process = require('child_process');
var SpringSimulator = require('./spring');
var CollisionSimulator = require('./collision');
var RenderSimulator = require('./model').RenderSimulator;
var optionator = require('./parser');
Matter.use(MatterAttractors);

var Engine = Matter.Engine,
  Render = Matter.Render,
  World = Matter.World,
  Composite = Matter.Composite,
  Body = Matter.Body,
  Vector = Matter.Vector,
  Events = Matter.Events,
  Bodies = Matter.Bodies;

function generate(args, idx) {
  if (args.physics == 'spring') {
    var simulator = new SpringSimulator(args);
  } else if (args.physics == 'collision') {
    var simulator = new CollisionSimulator(args);
  }

  var data = {
    encs:simulator.getEncs(),
  };

  // Run observation steps.
  while (true) {
    simulator.resetState();
    data.obs_states = [];
    for (var i = 0; i < args.numObsSteps; ++i) {
      simulator.nextStep();
      var state = simulator.getState();
      data.obs_states.push(state);


      if (args.imageBase) simulator.render(args.imageBase+'_'+idx+'_'+i+'.png');
    }

    if (simulator.isValidObs()) {
      break;
    }
  }

  if (args.physics == 'collision') {
    data.obs_collisions = simulator.collisions;
  }

  // Run rollout steps.
  while (true) {
    simulator.resetState();
    data.ro_states = [];
    for (var t = 0; t < args.numRoSteps; ++t) {
      simulator.nextStep();
      var state = simulator.getState();
      data.ro_states.push(state);

      if (args.imageBase) simulator.render(args.imageBase+'_'+idx+'_'+(args.numObsSteps+t)+'.png');
    }

    if (simulator.isValidRo()) {
      break;
    }
  }

  if (args.predictMean) {
    simulator.resetState(true);
    simulator.initEncs(true);
    var runStates = [];
    for (var t = 0; t < args.numRoSteps; ++t) {
      simulator.nextStep();
      var state = simulator.getState();
      runStates.push(state);
    }
    data.mean_states = [runStates];

    if (args.analyzeMean) {
      analyzeMean(data.ro_states, data.mean_states);
    }
  }

  // Return results on success
  // console.log("Ind:", idx, "Encs:", simulator.getEncs());
  return data;
}

var totMse = 0;
var totCount = 0;
function analyzeMean(ro_states, mean_states) {
  var ro_states = ro_states[0];
  var mean_states = mean_states[0];
  var tse = 0;
  var totalEuclidError = 0;
  var count = 0;
  for (var i = 0; i < ro_states.length; ++i) {
    for (var j = 0; j < ro_states[0].pos.length; ++j) {
      var errors = [
          Math.abs(ro_states[i].pos[j].x - mean_states[i].pos[j].x), 
          Math.abs(ro_states[i].pos[j].y - mean_states[i].pos[j].y)
      ];
 
      var se = errors[0] * errors[0] + errors[1] * errors[1];
      tse += .5 * se;
      totalEuclidError += Math.sqrt(se);
      ++count;
    }
  }
 
  // var mean_euclid_error = totalEuclidError / count;
  var mse = tse / count;
  totMse += mse;
  totCount++;
  return mse;
}

// Render for state file generated by this program.
function render(args, data) {
  var simulator = new RenderSimulator(args);
  if (simulator.bodies.length != data.obs_states[0].pos.length) console.log('Num bodies not matching!');

  for (var i = 0; i < data.obs_states.length; ++i) {
    for (var j = 0; j < simulator.bodies.length; ++j) {
      var pos = data.obs_states[i].pos[j];
      Body.setPosition(simulator.bodies[j], pos);
    }
    simulator.render(args.imageBase+'_'+i+'.png')
  }

  for (var i = 0; i < data.ro_states.length; ++i) {
    for (var j = 0; j < simulator.bodies.length; ++j) {
      var pos = data.ro_states[i].pos[j];
      Body.setPosition(simulator.bodies[j], pos);

      if (data.true_states) {
        if (args.analyzeMean) {
          var pos = data.mean_states[i].pos[j];
        } else {
          var pos = data.true_states[i].pos[j];
        }

        Body.setPosition(simulator.extraBodies[j], pos);
      }
    }
    simulator.render(args.imageBase+'_'+(i+data.obs_states.length)+'.png')
  }
}

// Render for state file generated by TF.
// function render(args, data) {
//   var simulator = new RenderSimulator(args);
//   for (var i = 0; i < data.states.length; ++i) {
//     for (var j = 0; j < simulator.bodies.length; ++j) {
//       var pos = data.states[i].pos[j];
//       Body.setPosition(simulator.bodies[j], pos);
// 
//       var pos = data.true_states[i].pos[j];
//       Body.setPosition(simulator.extraBodies[j], pos);
//     }
//     simulator.render(args.imageBase+'_'+i+'.png')
//   }
// }

function writeToFile(data, outputFile) {
  var text = JSON.stringify(data);
  fs.writeFileSync(outputFile, text);
}


function main() {
  // process invalid options
  try {
    var args = optionator.parseArgv(process.argv);
  } catch(e) {
      console.log(optionator.generateHelp());
      console.log(e.message)
      process.exit(1)
  }

  if (args.stateFile) { // render states from a state file. 
    fs.readFile(args.stateFile, function(err, data) {
      if (err) return console.log(err);
      data = JSON.parse(data);
      render(args, data);
    });
  } else { // generate states from scratch.
    var dataBatch = [];
    for (var idx = args.startIdx; idx < args.numGroups; ++idx) {
      if (idx % 1000 == 0) {
        console.log("Ind:", idx);
        if (args.analyzeMean) {
          console.log("MSE:", totMse / totCount);
        }
      }
      var data = generate(args, idx);
      if (data) { // Successful run
        if (args.batch) {
          dataBatch.push(data);
          if (dataBatch.length == args.batchSize) {
            writeToFile(dataBatch, args.outputBase+'_'+idx+'.json');
            dataBatch = [];
          }
        } else {
          writeToFile(data, args.outputBase+'_'+idx+'.json');
        }
      } else { // Unsuccessful run
        --idx;
      }
    }
  }
}

main();

